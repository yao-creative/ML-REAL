programming languages are used for controlling the behavior of a machine (often a computer). like natural languages, programming languages follow the rules for syntax and semantics.
there are thousands of programming languages and new ones are created every year. few languages ever become sufficiently popular that they are used by more than a few people, but professional programmers may use dozens of languages in a career.
most programming languages are not standardized by an international (or national) standard, even widely used ones, such as perl or standard ml (despite the name). notable standardized programming languages include algol, c, c++, javascript (under the name ecmascript), smalltalk, prolog, common lisp, scheme (ieee standard), islisp, ada, fortran, cobol, sql and xquery.


== general comparison ==
the following table compares general and technical information for a selection of commonly used programming languages. see the individual languages' articles for further information.


== type systems ==


== failsafe i/o and system calls ==
most programming languages will print an error message or throw an exception if an input/output operation or other system call (e.g., chmod, kill) fails, unless the programmer has explicitly arranged for different handling of these events. thus, these languages fail safely in this regard.
some (mostly older) languages require that the programmer explicitly add checks for these kinds of errors. psychologically, different cognitive biases (e.g., optimism bias) may affect novice and experts alike and these omissions can lead to erroneous behavior.


== expressiveness ==
the literature on programming languages contains an abundance of informal claims about their relative expressive power, but there is no framework for formalizing such statements nor for deriving interesting consequences. this table provides two measures of expressiveness from two different sources. an additional measure of expressiveness, in gzip bytes, can be found on the computer language benchmarks game.


== benchmarks ==

benchmarks are designed to mimic a particular type of workload on a component or system. the computer programs used for compiling some of the benchmark data in this section may not have been fully optimized, and the relevance of the data is disputed. the most accurate benchmarks are those that are customized to your particular situation. other people's benchmark data may have some value to others, but proper interpretation brings many challenges. the computer language benchmarks game site warns against over-generalizing from benchmark data, but contains a large number of micro-benchmarks of reader-contributed code snippets, with an interface that generates various charts and tables comparing specific programming languages and types of tests.


== timeline of specific language comparisons ==
1974 – comparative notes on algol 68 and pl/i – s. h. valentine – november 1974
1976 – evaluation of algol 68, jovial j3b, pascal, simula 67, and tacpol versus tinman – requirements for a common high order programming language.
1977 – a comparison of pascal and algol 68 – andrew s. tanenbaum – june 1977.
1993 – five little languages and how they grew – bliss, pascal, algol 68, bcpl & c – dennis m. ritchie – april 1993.
2009 – on go – oh, go on – how well will google's go stand up against brand x programming language? – david given – november 2009


== see also ==
comparison of basic instructions of programming languages
comparison of programming languages (syntax)
comparison of programming paradigms
comparison of integrated development environments
comparison of multi-paradigm programming languages
measuring programming language popularity
tiobe index


== references ==


== further reading ==
cezzar, ruknet (1995). a guide to programming languages: overview and comparison. isbn 978-0-89006-812-0.